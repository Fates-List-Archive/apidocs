# coding: utf-8

"""
    Fates List

                 Current API: v2 beta 3             Default API: v2             API URL: https://api.fateslist.xyz             API Docs: https://apidocs.fateslist.xyz             Enum Reference: https://apidocs.fateslist.xyz/structures/enums.autogen           # noqa: E501

    OpenAPI spec version: 0.4.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class APIV2BotsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def bot_exists(self, bot_id, **kwargs):  # noqa: E501
        """Bot Exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bot_exists(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.bot_exists_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.bot_exists_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def bot_exists_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Bot Exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.bot_exists_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method bot_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `bot_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_bot(self, bot_id, **kwargs):  # noqa: E501
        """Fetch Bot  # noqa: E501

        Fetches bot information given a bot ID. If not found, 404 will be returned.   This endpoint handles both bot IDs and client IDs  - **compact** (default `true`) -> long_description_type, long_description, css and keep_banner_decor will be not be given  - **no_cache** (default: `false`) -> cached responses will not be served (may be temp disabled in the case of a DDOS or temp disabled for specific  bots as required). **Uncached requests may take up to 100-200 times longer or possibly more**  **Important note: the first owner may or may not be the main owner.  Use the `main` key instead of object order**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_bot(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param bool compact:
        :param bool no_cache:
        :return: Bot
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_bot_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_bot_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def fetch_bot_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Fetch Bot  # noqa: E501

        Fetches bot information given a bot ID. If not found, 404 will be returned.   This endpoint handles both bot IDs and client IDs  - **compact** (default `true`) -> long_description_type, long_description, css and keep_banner_decor will be not be given  - **no_cache** (default: `false`) -> cached responses will not be served (may be temp disabled in the case of a DDOS or temp disabled for specific  bots as required). **Uncached requests may take up to 100-200 times longer or possibly more**  **Important note: the first owner may or may not be the main owner.  Use the `main` key instead of object order**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_bot_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param bool compact:
        :param bool no_cache:
        :return: Bot
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id', 'compact', 'no_cache']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_bot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `fetch_bot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []
        if 'compact' in params:
            query_params.append(('compact', params['compact']))  # noqa: E501
        if 'no_cache' in params:
            query_params.append(('no_cache', params['no_cache']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Bot',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_random_bot(self, bot_id, **kwargs):  # noqa: E501
        """Fetch Random Bot  # noqa: E501

        Fetch a random bot. Bot ID should be the root bot 0   Example: ```py import requests  def random_bot():     res = requests.get(\"https://fateslist.xyz/api/bots/0/random\")     json = res.json()     if not json.get(\"done\", True):         # Handle an error in the api         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_random_bot(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param str lang:
        :return: BotRandom
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_random_bot_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_random_bot_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def fetch_random_bot_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Fetch Random Bot  # noqa: E501

        Fetch a random bot. Bot ID should be the root bot 0   Example: ```py import requests  def random_bot():     res = requests.get(\"https://fateslist.xyz/api/bots/0/random\")     json = res.json()     if not json.get(\"done\", True):         # Handle an error in the api         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_random_bot_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param str lang:
        :return: BotRandom
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id', 'lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_random_bot" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `fetch_random_bot`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/random', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='BotRandom',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bot_invite(self, bot_id, **kwargs):  # noqa: E501
        """Get Bot Invite  # noqa: E501

        Internally used by sunbeam for inviting users.  While the data you get from this API is sanitized because it is actually rendered for users, it is *not* recommended to rely or use this API outside of internal use cases. Data is unstructured and will constantly change. **This API is not backwards compatible whatsoever**  Additionally, this API *will* trigger a WS Invite Event.  To protect against scraping, this endpoint requires a proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_invite(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param int user_id:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bot_invite_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bot_invite_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def get_bot_invite_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Get Bot Invite  # noqa: E501

        Internally used by sunbeam for inviting users.  While the data you get from this API is sanitized because it is actually rendered for users, it is *not* recommended to rely or use this API outside of internal use cases. Data is unstructured and will constantly change. **This API is not backwards compatible whatsoever**  Additionally, this API *will* trigger a WS Invite Event.  To protect against scraping, this endpoint requires a proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_invite_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param int user_id:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bot_invite" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `get_bot_invite`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []
        if 'user_id' in params:
            query_params.append(('user_id', params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/_sunbeam/invite', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bot_page(self, bot_id, **kwargs):  # noqa: E501
        """Get Bot Page  # noqa: E501

        Internally used by sunbeam to render bot pages.  While the data you get from this API is sanitized because it is actually rendered for users, it is *not* recommended to rely or use this API outside of internal use cases. Data is unstructured and will constantly change. **This API is not backwards compatible whatsoever**  Additionally, this API *will* trigger a WS View Event.  To protect against scraping and browsers, this endpoint requires a  proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  Response models will *never* be documented as it changes very frequently  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_page(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param str lang:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bot_page_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bot_page_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def get_bot_page_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Get Bot Page  # noqa: E501

        Internally used by sunbeam to render bot pages.  While the data you get from this API is sanitized because it is actually rendered for users, it is *not* recommended to rely or use this API outside of internal use cases. Data is unstructured and will constantly change. **This API is not backwards compatible whatsoever**  Additionally, this API *will* trigger a WS View Event.  To protect against scraping and browsers, this endpoint requires a  proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  Response models will *never* be documented as it changes very frequently  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_page_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param str lang:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id', 'lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bot_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `get_bot_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/_sunbeam', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bot_settings(self, bot_id, user_id, **kwargs):  # noqa: E501
        """Get Bot Settings  # noqa: E501

        Internally used by sunbeam for bot settings.  While the data you get from this API is sanitized because it is actually rendered for users, it is *not* recommended to rely or use this API outside of internal use cases. Data is unstructured and will constantly change. **This API is not backwards compatible whatsoever**  To protect against scraping, this endpoint requires a proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_settings(bot_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param int user_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bot_settings_with_http_info(bot_id, user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bot_settings_with_http_info(bot_id, user_id, **kwargs)  # noqa: E501
            return data

    def get_bot_settings_with_http_info(self, bot_id, user_id, **kwargs):  # noqa: E501
        """Get Bot Settings  # noqa: E501

        Internally used by sunbeam for bot settings.  While the data you get from this API is sanitized because it is actually rendered for users, it is *not* recommended to rely or use this API outside of internal use cases. Data is unstructured and will constantly change. **This API is not backwards compatible whatsoever**  To protect against scraping, this endpoint requires a proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_settings_with_http_info(bot_id, user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param int user_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id', 'user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bot_settings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `get_bot_settings`")  # noqa: E501
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_bot_settings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []
        if 'user_id' in params:
            query_params.append(('user_id', params['user_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['User']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/_sunbeam/settings', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bot_widget(self, bot_id, format, **kwargs):  # noqa: E501
        """Bot Widget  # noqa: E501

        Returns a bots widget. This has been superceded by Get Widget and merely redirects to it now  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_widget(bot_id, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param WidgetFormat format: (required)
        :param Bgcolor1 bgcolor:
        :param Textcolor1 textcolor:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bot_widget_with_http_info(bot_id, format, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bot_widget_with_http_info(bot_id, format, **kwargs)  # noqa: E501
            return data

    def get_bot_widget_with_http_info(self, bot_id, format, **kwargs):  # noqa: E501
        """Bot Widget  # noqa: E501

        Returns a bots widget. This has been superceded by Get Widget and merely redirects to it now  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_widget_with_http_info(bot_id, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :param WidgetFormat format: (required)
        :param Bgcolor1 bgcolor:
        :param Textcolor1 textcolor:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id', 'format', 'bgcolor', 'textcolor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bot_widget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `get_bot_widget`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_bot_widget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'bgcolor' in params:
            query_params.append(('bgcolor', params['bgcolor']))  # noqa: E501
        if 'textcolor' in params:
            query_params.append(('textcolor', params['textcolor']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/widget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_bot_ws_events(self, bot_id, **kwargs):  # noqa: E501
        """Get Bot Ws Events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_ws_events(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_bot_ws_events_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_bot_ws_events_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def get_bot_ws_events_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Get Bot Ws Events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_bot_ws_events_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_bot_ws_events" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `get_bot_ws_events`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bot']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/ws_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_votes_per_month(self, bot_id, **kwargs):  # noqa: E501
        """Get Votes Per Month  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_votes_per_month(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_votes_per_month_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_votes_per_month_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def get_votes_per_month_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Get Votes Per Month  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_votes_per_month_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_votes_per_month" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `get_votes_per_month`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/vpm', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def regenerate_bot_token(self, bot_id, **kwargs):  # noqa: E501
        """Regenerate Bot Token  # noqa: E501

        Regenerates a bot token. Use this if it is compromised   Example:  ```py import requests  def regen_token(bot_id, token):     res = requests.patch(f\"https://fateslist.xyz/api/v2/bots/{bot_id}/token\", headers={\"Authorization\": f\"Bot {token}\"})     json = res.json()     if not json[\"done\"]:         # Handle failures         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.regenerate_bot_token(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: APIResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.regenerate_bot_token_with_http_info(bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.regenerate_bot_token_with_http_info(bot_id, **kwargs)  # noqa: E501
            return data

    def regenerate_bot_token_with_http_info(self, bot_id, **kwargs):  # noqa: E501
        """Regenerate Bot Token  # noqa: E501

        Regenerates a bot token. Use this if it is compromised   Example:  ```py import requests  def regen_token(bot_id, token):     res = requests.patch(f\"https://fateslist.xyz/api/v2/bots/{bot_id}/token\", headers={\"Authorization\": f\"Bot {token}\"})     json = res.json()     if not json[\"done\"]:         # Handle failures         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.regenerate_bot_token_with_http_info(bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int bot_id: (required)
        :return: APIResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['bot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method regenerate_bot_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `regenerate_bot_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bot']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/token', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_bot_stats(self, body, bot_id, **kwargs):  # noqa: E501
        """Set Bot Stats  # noqa: E501

        This endpoint allows you to set the guild + shard counts for your bot   Example: ```py # This will use aiohttp and not requests as this is likely to used by discord.py bots import aiohttp   # On dpy, guild_count is usually the below guild_count = len(client.guilds)  # If you are using sharding shard_count = len(client.shards) shards = client.shards.keys()  # Optional: User count (this is not accurate for larger bots) user_count = len(client.users)   async def set_stats(bot_id, token, guild_count, shard_count = None, shards = None, user_count = None):     json = {\"guild_count\": guild_count, \"shard_count\": shard_count, \"shards\": shards, \"user_count\": user_count}      async with aiohttp.ClientSession() as sess:         async with sess.post(f\"https://fateslist.xyz/api/bots/{bot_id}/stats\", headers={\"Authorization\": f\"Bot {token}\"}, json=json) as res:             json = await res.json()             if not json[\"done\"]:                 # Handle or log this error                 ... ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_bot_stats(body, bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BotStats body: (required)
        :param int bot_id: (required)
        :return: APIResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_bot_stats_with_http_info(body, bot_id, **kwargs)  # noqa: E501
        else:
            (data) = self.set_bot_stats_with_http_info(body, bot_id, **kwargs)  # noqa: E501
            return data

    def set_bot_stats_with_http_info(self, body, bot_id, **kwargs):  # noqa: E501
        """Set Bot Stats  # noqa: E501

        This endpoint allows you to set the guild + shard counts for your bot   Example: ```py # This will use aiohttp and not requests as this is likely to used by discord.py bots import aiohttp   # On dpy, guild_count is usually the below guild_count = len(client.guilds)  # If you are using sharding shard_count = len(client.shards) shards = client.shards.keys()  # Optional: User count (this is not accurate for larger bots) user_count = len(client.users)   async def set_stats(bot_id, token, guild_count, shard_count = None, shards = None, user_count = None):     json = {\"guild_count\": guild_count, \"shard_count\": shard_count, \"shards\": shards, \"user_count\": user_count}      async with aiohttp.ClientSession() as sess:         async with sess.post(f\"https://fateslist.xyz/api/bots/{bot_id}/stats\", headers={\"Authorization\": f\"Bot {token}\"}, json=json) as res:             json = await res.json()             if not json[\"done\"]:                 # Handle or log this error                 ... ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_bot_stats_with_http_info(body, bot_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BotStats body: (required)
        :param int bot_id: (required)
        :return: APIResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'bot_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_bot_stats" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_bot_stats`")  # noqa: E501
        # verify the required parameter 'bot_id' is set
        if ('bot_id' not in params or
                params['bot_id'] is None):
            raise ValueError("Missing the required parameter `bot_id` when calling `set_bot_stats`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'bot_id' in params:
            path_params['bot_id'] = params['bot_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Bot']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/bots/{bot_id}/stats', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
