# coding: utf-8

"""
    Fates List

                 Current API: v2 beta 3             Default API: v2             API URL: https://api.fateslist.xyz             API Docs: https://apidocs.fateslist.xyz             Enum Reference: https://apidocs.fateslist.xyz/structures/enums.autogen           # noqa: E501

    OpenAPI spec version: 0.4.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class APIV2ServersApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def fetch_random_server(self, guild_id, **kwargs):  # noqa: E501
        """Fetch Random Server  # noqa: E501

        Fetch a random server. Server ID should be the recursive/root server 0.   Example: ```py import requests  def random_server():     res = requests.get(\"https://fateslist.xyz/api/guilds/0/random\")     json = res.json()     if not json.get(\"done\", True):         # Handle an error in the api         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_random_server(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param str lang:
        :return: GuildRandom
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_random_server_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_random_server_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def fetch_random_server_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Fetch Random Server  # noqa: E501

        Fetch a random server. Server ID should be the recursive/root server 0.   Example: ```py import requests  def random_server():     res = requests.get(\"https://fateslist.xyz/api/guilds/0/random\")     json = res.json()     if not json.get(\"done\", True):         # Handle an error in the api         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_random_server_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param str lang:
        :return: GuildRandom
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id', 'lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_random_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `fetch_random_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}/random', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='GuildRandom',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def fetch_server(self, guild_id, **kwargs):  # noqa: E501
        """Fetch Server  # noqa: E501

        Fetches server information given a server/guild ID. If not found, 404 will be returned.  Setting compact to true (default) -> description, long_description, long_description_type, keep_banner_decor and css will be null  No cache means cached responses will not be served (may be temp disabled in the case of a DDOS or temp disabled for specific servers as required)  Setting sensitive to true will expose sensitive info like invite channel, user whitelist/blacklist etc  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_server(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param bool compact:
        :param bool no_cache:
        :param bool sensitive:
        :return: Guild
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.fetch_server_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.fetch_server_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def fetch_server_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Fetch Server  # noqa: E501

        Fetches server information given a server/guild ID. If not found, 404 will be returned.  Setting compact to true (default) -> description, long_description, long_description_type, keep_banner_decor and css will be null  No cache means cached responses will not be served (may be temp disabled in the case of a DDOS or temp disabled for specific servers as required)  Setting sensitive to true will expose sensitive info like invite channel, user whitelist/blacklist etc  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.fetch_server_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param bool compact:
        :param bool no_cache:
        :param bool sensitive:
        :return: Guild
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id', 'compact', 'no_cache', 'sensitive']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method fetch_server" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `fetch_server`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []
        if 'compact' in params:
            query_params.append(('compact', params['compact']))  # noqa: E501
        if 'no_cache' in params:
            query_params.append(('no_cache', params['no_cache']))  # noqa: E501
        if 'sensitive' in params:
            query_params.append(('sensitive', params['sensitive']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Guild',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_invite(self, guild_id, **kwargs):  # noqa: E501
        """Get Server Invite  # noqa: E501

        Internally used by sunbeam for inviting users.  **Usage of this API without explicit permission from said servers is not allowed**  Additionally, this API *will* trigger a WS Invite Event.  To protect against scraping, this endpoint requires a proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_invite(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_server_invite_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_server_invite_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def get_server_invite_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Get Server Invite  # noqa: E501

        Internally used by sunbeam for inviting users.  **Usage of this API without explicit permission from said servers is not allowed**  Additionally, this API *will* trigger a WS Invite Event.  To protect against scraping, this endpoint requires a proper Frostpaw header to be set.  This API will also be heavily monitored. If we find you attempting to abuse this API endpoint or doing anything out of the ordinary with it, you may be IP or user banned. Calling it once or twice is OK but automating it is not. Use the Get Bot API instead for automation.  **This API is only documented because it's in our FastAPI backend and to be complete**  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_invite_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_invite" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `get_server_invite`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}/_sunbeam/invite', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_page(self, guild_id, **kwargs):  # noqa: E501
        """Get Server Page  # noqa: E501

        Internally used by sunbeam for server page getting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_page(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param str lang:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_server_page_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_server_page_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def get_server_page_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Get Server Page  # noqa: E501

        Internally used by sunbeam for server page getting.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_page_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param str lang:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id', 'lang']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_page" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `get_server_page`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []
        if 'lang' in params:
            query_params.append(('lang', params['lang']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}/_sunbeam', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_widget(self, guild_id, format, **kwargs):  # noqa: E501
        """Server Widget  # noqa: E501

        Returns a widget. Superceded by Get Widget API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_widget(guild_id, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param WidgetFormat format: (required)
        :param Bgcolor bgcolor:
        :param Textcolor textcolor:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_server_widget_with_http_info(guild_id, format, **kwargs)  # noqa: E501
        else:
            (data) = self.get_server_widget_with_http_info(guild_id, format, **kwargs)  # noqa: E501
            return data

    def get_server_widget_with_http_info(self, guild_id, format, **kwargs):  # noqa: E501
        """Server Widget  # noqa: E501

        Returns a widget. Superceded by Get Widget API  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_widget_with_http_info(guild_id, format, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :param WidgetFormat format: (required)
        :param Bgcolor bgcolor:
        :param Textcolor textcolor:
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id', 'format', 'bgcolor', 'textcolor']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_widget" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `get_server_widget`")  # noqa: E501
        # verify the required parameter 'format' is set
        if ('format' not in params or
                params['format'] is None):
            raise ValueError("Missing the required parameter `format` when calling `get_server_widget`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []
        if 'format' in params:
            query_params.append(('format', params['format']))  # noqa: E501
        if 'bgcolor' in params:
            query_params.append(('bgcolor', params['bgcolor']))  # noqa: E501
        if 'textcolor' in params:
            query_params.append(('textcolor', params['textcolor']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}/widget', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_server_ws_events(self, guild_id, **kwargs):  # noqa: E501
        """Get Server Ws Events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_ws_events(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_server_ws_events_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_server_ws_events_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def get_server_ws_events_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Get Server Ws Events  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_server_ws_events_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_server_ws_events" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `get_server_ws_events`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Server']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}/ws_events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def regenerate_server_token(self, guild_id, **kwargs):  # noqa: E501
        """Regenerate Server Token  # noqa: E501

        Regenerates a server token. Use this if it is compromised and you don't have time to use slash commands   Example:  ```py import requests  def regen_token(guild_id, token):     res = requests.patch(f\"https://fateslist.xyz/api/v2/guilds/{guild_id}/token\", headers={\"Authorization\": f\"Server {token}\"})     json = res.json()     if not json[\"done\"]:         # Handle failures         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.regenerate_server_token(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: APIResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.regenerate_server_token_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.regenerate_server_token_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def regenerate_server_token_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Regenerate Server Token  # noqa: E501

        Regenerates a server token. Use this if it is compromised and you don't have time to use slash commands   Example:  ```py import requests  def regen_token(guild_id, token):     res = requests.patch(f\"https://fateslist.xyz/api/v2/guilds/{guild_id}/token\", headers={\"Authorization\": f\"Server {token}\"})     json = res.json()     if not json[\"done\"]:         # Handle failures         ...     return res, json ```  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.regenerate_server_token_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: APIResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method regenerate_server_token" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `regenerate_server_token`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['Server']  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}/token', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='APIResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def server_exists(self, guild_id, **kwargs):  # noqa: E501
        """Server Exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.server_exists(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.server_exists_with_http_info(guild_id, **kwargs)  # noqa: E501
        else:
            (data) = self.server_exists_with_http_info(guild_id, **kwargs)  # noqa: E501
            return data

    def server_exists_with_http_info(self, guild_id, **kwargs):  # noqa: E501
        """Server Exists  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.server_exists_with_http_info(guild_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int guild_id: (required)
        :return: object
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['guild_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method server_exists" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'guild_id' is set
        if ('guild_id' not in params or
                params['guild_id'] is None):
            raise ValueError("Missing the required parameter `guild_id` when calling `server_exists`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'guild_id' in params:
            path_params['guild_id'] = params['guild_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/api/v2/guilds/{guild_id}', 'HEAD',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='object',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
